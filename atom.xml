<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://croatiaparanoia.github.io/blog/</id>
    <title>🦌</title>
    <updated>2021-01-04T11:09:27.481Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://croatiaparanoia.github.io/blog/"/>
    <link rel="self" href="https://croatiaparanoia.github.io/blog/atom.xml"/>
    <subtitle>万物皆有裂痕，那是光照进来的地方。</subtitle>
    <logo>https://croatiaparanoia.github.io/blog/images/avatar.png</logo>
    <icon>https://croatiaparanoia.github.io/blog/favicon.ico</icon>
    <rights>All rights reserved 2021, 🦌</rights>
    <entry>
        <title type="html"><![CDATA[Polyfill]]></title>
        <id>https://croatiaparanoia.github.io/blog/post/polyfill/</id>
        <link href="https://croatiaparanoia.github.io/blog/post/polyfill/">
        </link>
        <updated>2020-11-11T11:03:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="听闻你这包不愿给我加polyfill">听闻你这包不愿给我加polyfill？</h1>
<figure data-type="image" tabindex="1"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758259689.jpg" alt="" loading="lazy"></figure>
<p>曾经有写了个工具库发到了npm， 最近有位老哥说这个库低版本浏览器不兼容， 如 数组的 includes 方法之类的。我随即看了下，确实吼， tsc 只是把语法糖的转译了， 至于高级API特性的，还是那个样子。</p>
<p>随即准备给库加polyfill， 但是想了下。 嘿， 这第三方库的， 我要是加了polyfill， 那要是有其他人不考虑浏览器兼容性问题的呢， 那岂不是polyfill得代码都用不到， 徒增体积？</p>
<figure data-type="image" tabindex="2"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758267270.jpg" alt="" loading="lazy"></figure>
<p>那好勒， 既然这第三方库不打算整合polyfill， 那就是让使用方去用babel转译这个第三方库了。但是第三方行不行呢， 我心里还真发怵，也不敢直接跟人家说，本着毛主席的“没有调查就没有发言权”原则， 我决定自己去 try 一 try。</p>
<h2 id="随便搞个项目">随便搞个项目</h2>
<p>首先， 那就是项目基础了。</p>
<pre><code class="language-shell">mkdir support-ie

cd support-ie

npm init -y

yarn add webpack webpack-cli --dev

# 装上我那个可怜的包
yarn add ffformat

# 装上 babel 相关依赖
yarn add @babel/core @babel/preset-env @babel/plugin-transform-run-time babel-loader --dev

# 装上 core-js。 按需引入 polyfill 之类的就取这里面的了
yarn add core-js

# 创建 webpack 配置文件
touch webpack.config.js

# 创建 babel 配置文件 
touch babel.config.json

# 源代码文件
mkdir src &amp;&amp; cd src &amp;&amp; touch main.js
</code></pre>
<p>文件创建的差不多，然后就是配制 config 文件了</p>
<pre><code class="language-javascript">// webpack.config.js
const path = require(&quot;path&quot;);

module.exports = {
  entry: {
    main: &quot;./src/main.js&quot;,
  },
  output: &quot;/dist/main.js&quot;,
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: &quot;babel-loader&quot;,
        include: [
          path.resolve(__dirname, &quot;./src&quot;),
          // 这里要把第三方包加入到include中， 不然loader不会去转译
          path.resolve(__dirname, &quot;node_modules/ffformat&quot;),
        ],
      },
    ],
  },
  optimization: {
    minimize: false,
  },
};
</code></pre>
<p>接着是babel 的配置文件</p>
<pre><code class="language-json">// babel.config.json
{
  &quot;presets&quot;: [
    [
      &quot;@babel/env&quot;,
      {
        // 指明 corejs 的版本，（不同版本的文件和命名方式有区别，避免找文件报错， 所以要指明版本）
        &quot;corejs&quot;: 3,
        // 兼容ie9
        &quot;targets&quot;: {
          &quot;ie&quot;: 9,
        },
        // 使用这个按需引入polyfill
        &quot;useBuiltIns&quot;: &quot;usage&quot;
      }
    ]
  ]
}
</code></pre>
<p>紧接着，我们开始在 <code>src/main.js</code> 写上一段代码</p>
<pre><code class="language-javascript">// src/main.js
import * as ffformat from 'ffforamt';

console.log(ffformat);
</code></pre>
<p>然后根目录运行webpack一次 **<code>npx webpack</code> **</p>
<p>就可以看到 打包 <code>main.js</code> 的时候， 引入了一些 <code>core-js</code> 下面的模块， 去看 dist/main.js ， 就能看到针对一些高级特性， 有做了 polyfill。</p>
<p>致此， 正常流程完。</p>
<figure data-type="image" tabindex="3"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758276421.jpg" alt="" loading="lazy"></figure>
<h2 id="遇到的问题">遇到的问题</h2>
<h3 id="1-babel-配置文件的问题">1. Babel 配置文件的问题</h3>
<p>刚开始的时候， 用的是 <code>.babelrc</code> 来配置babel， 结果loader 一直不走 <code>node_modules</code> ， 不转译 <code>node_modules</code> 中的代码，卡了半天，不断找文章，后来发现了一位老哥的话。</p>
<figure data-type="image" tabindex="4"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758282188.png" alt="" loading="lazy"></figure>
<p>随即将 <code>.babelrc</code>  重命名为 <code>babel.config.json</code>， 再 <code>npx webpack</code> ， 成功给 <code>node_modules</code> 中的 <code>ffformat</code> 整入 <code>polyfill</code> 部分的代码。看到这个结果差点把我送走。 这卡了半天的问题， 改了个名字就好了。。。</p>
<figure data-type="image" tabindex="5"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758287255.jpeg" alt="" loading="lazy"></figure>
<h3 id="2-多种polyfill方式">2. 多种polyfill方式</h3>
<ol>
<li>
<p>按需引入方式， 用到哪个高级特性， 就自动加入这个特性的polyfill。 （即 本文写的方式）</p>
</li>
<li>
<p>全量引入方式。在入口文件顶部加入这两行。</p>
<pre><code class="language-javascript">import &quot;core-js/stable&quot;;
import &quot;regenerator-runtime/runtime&quot;;
</code></pre>
</li>
<li>
<p>动态引入方式。这个是在 <a href="https://polyfill.io">polyfill.io</a> 去配置一个外链。配置需要兼容的es版本 或者 需要的对应api。然后 用 script 标签引入该外链， 就会返回对应的一些<code>polyfill</code>代码。（因 script 的src 属于get请求， 所以服务器那边可以知道我们浏览器的 userAgent， 然后根据这个去判断我们浏览器， 给浏览器响应对应的polyfill。 所以用高版本浏览器去访问此请求， 可能返回的内容是空的）</p>
</li>
</ol>
<p>三种方式， 感觉第一种和第三种偏好一点。</p>
<p>第一种的按需引入， 不会因为就一个 高级特性的api， 就导致整个bundle文件瞬间增大N多倍。</p>
<p>第三种则是 指定es版本， 由服务器决定需要返回哪些polyfill。这样相当于是将所有的polyfill 都抽离出去，用别人家的cdn引入进来。</p>
<p>至于选择上， 如果说 请求 <a href="https://polyfill.io">polyfill.io</a> 的速度过慢， 或者项目内网部署，那么选择第一种方式是更好的。</p>
<p>而如果项目可以访问外网资源。并且访问 <a href="https://polyfill.io">polyfill.io</a> 外链速度足够快， 那么用第三种也是极好的。</p>
<p>当然，  如果项目没有涉及到 <code>webpack</code>， <code>rollup</code>之类的构建工具， 只是纯的项目，那么只能选择第三种了。</p>
<p>如果没用 构架工具， 还要内网部署， 那就把外链的 polyfill 下载下来，放到本地再一并部署上去。</p>
<figure data-type="image" tabindex="6"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758295721.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Event Loop]]></title>
        <id>https://croatiaparanoia.github.io/blog/post/event-loop/</id>
        <link href="https://croatiaparanoia.github.io/blog/post/event-loop/">
        </link>
        <updated>2020-10-02T10:20:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="任务分发器">任务分发器</h2>
<p>一般的， 下面这些<strong>标签或者API</strong>都可以让一些任务<strong>间接</strong>的进入各自的队列。</p>
<p>任务：script、setTimeout、setInterval，DOM事件绑定， 请求响应等</p>
<p>微任务：promise</p>
<h2 id="event-loop-周期组成">Event Loop 周期组成</h2>
<ol>
<li>
<p>TASK 阶段 （重点就在这）</p>
<ul>
<li>任务调度和执行。 任务中代码执行完毕，调用栈清空后，开始执行微任务队列中的微任务。循环如此， 直至没有微任务，开始下一个任务。如果没有下一个任务， 则进入rAF。</li>
</ul>
</li>
<li>
<p>rAF(<strong>r</strong>equest<strong>A</strong>nimation<strong>F</strong>rame)阶段 - 所有任务执行完毕之后， 页面渲染之前。</p>
</li>
<li>
<p>Style  阶段 - 样式计算， 计算应用到元素上的样式。</p>
</li>
<li>
<p>Layout  阶段 - 创建渲染树， 找出页面上的所有内容及位置。</p>
</li>
<li>
<p>Paint  阶段 - 绘制内容到页面上。</p>
</li>
</ol>
<p>总的来分的话， 可以将上面五个阶段化为两个：</p>
<ol>
<li>TASK 阶段， 主要就是<strong>任务的调度和执行</strong>。 <code>Webapis</code> 推任务到任务队列，事件循环在合适的时候 将任务取出压入调用栈执行和弹出。</li>
<li>渲染绘制阶段，从2到4， 主要就是 绘制前的逻辑执行， 以及视图相关的绘制了。</li>
</ol>
<p>注：微任务的执行，取决于调用栈。调用栈为空才会执行微任务。</p>
<figure data-type="image" tabindex="1"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755671039.png" alt="轨迹图" loading="lazy"></figure>
<h2 id="个人理解的事件循环的一个流程">个人理解的事件循环的一个流程</h2>
<ol>
<li>事件循环不断的判断 任务队列是否有值， 并且调用栈为空。（同时会在每隔16毫秒左右去进行一次视图绘制）</li>
<li><code>Webapis</code>  得到任务， 并在合适的时候将任务推入任务队列。</li>
<li>当有任务队列有值， 并且调用栈查询到的状态为空。则从任务队列中<strong>取出第一个任务</strong>， 压入调用栈，并开始执行该任务。（此时该任务在调用栈最底部）
<ol>
<li>任务代码执行时， 可能会分发新的任务， 比如设置定时器， 发起网络请求，监听事件这些操作。这些都会交与 <code>Webapis</code> 。 当定时器时间满足， 请求响应回来， 监听到事件这些时候，***<code>Webapis</code>  会在下一轮事件循环， 将这些满足条件的任务推入任务队列，等待事件循环的调度。***</li>
<li>任务代码执行时， 可能会分发新的微任务， 如 Promise.resolve().then(cb) 这种的， 此时，将cb函数交推入微任务队列。等待事件循环的调度。</li>
<li>当该任务中代码执行完毕后， 弹出任务，调用栈清空。</li>
<li>判断微任务队列是否有值， 如果有，则从中取出第一个微任务， 压入调用栈并执行，执行完毕 弹出。（反复此操作， 直至微任务队列为空）</li>
<li>当微任务队列为空， 且调用栈已清空时， 则开始下一个任务。</li>
</ol>
</li>
<li>重复第三条，直至任务队列为空， 且调用栈为空。</li>
<li>进入 渲染绘制 阶段， 依次调用 requestAnimationFrame 队列中的任务（此任务中进行分发任务和微任务， 参考3-1 到 3-5）。然后进入 <strong>Style Calculation</strong>、<strong>Layout Calculation</strong>、<strong>Paint</strong> 阶段。完成后开始新的一轮事件循环。（对于新的一轮事件循环判定的标准是 <strong>走过了 渲染绘制 阶段</strong>）</li>
<li>每轮 事件循环 开始时， 如果调用栈为空并且任务队列有值， 就会走上面的 第三到第五条的流程。</li>
<li>如果调用栈为空， 并且任务队列也为空， 则事件循环会进入空转状态（每隔16毫秒左右进行一次视图绘制， 即 每隔16ms 会走一次第五条）。</li>
</ol>
<h2 id="测试demo">测试Demo</h2>
<h3 id="1-由-settimeout-分发出来的任务">① 由 setTimeout 分发出来的任务</h3>
<pre><code class="language-javascript">console.log(&quot;glob1&quot;);

setTimeout(function timeout1Cb() {
  console.log(&quot;timeout1&quot;);
  new Promise(function timeout1PromiseCb(resolve) {
    console.log(&quot;timeout1_promise&quot;);
    resolve();
  }).then(function timeout1ThenCb() {
    console.log(&quot;timeout1_then&quot;);
  });
});

new Promise(function promise1Cb(resolve) {
  console.log(&quot;glob1_promise&quot;);
  resolve();
}).then(function promise1ThenCb() {
  console.log(&quot;glob1_then&quot;);
});

setTimeout(function timeout2Cb() {
  console.log(&quot;timeout2&quot;);
  new Promise(function timeout2PromiseCb(resolve) {
    console.log(&quot;timeout2_promise&quot;);
    resolve();
  }).then(function timeout2ThenCb() {
    console.log(&quot;timeout2_then&quot;);
  });
});

new Promise(function promise2Cb(resolve) {
  console.log(&quot;glob2_promise&quot;);
  resolve();
}).then(function promise2ThenCb() {
  console.log(&quot;glob2_then&quot;);
});

/**
解析：
1. 代码开始执行， 第一个 log 是 &quot;glob1&quot; 无疑。
2. 执行 `setTimeout(timeout1Cb)`， 将 `timeout1Cb` 交与 ` `Webapis` `， 等待 ` `Webapis` ` 在下一轮事件循环推入 任务队列。
3. 实例化 promise， 传入 promise1Cb 执行器，执行 promise1Cb。输出 &quot;glob1_promise&quot;
4. 调用 `resolve();` 往微任务队列中推了一个任务 `promise1ThenCb`。
5. 执行 `setTimeout(timeout2Cb)`， 将 `timeout2Cb` 交与 ` `Webapis` `， 等待 ` `Webapis` ` 在下一轮事件循环推入 任务队列。
6. 实例化 promise， 传入 promise2Cb 执行器，执行 promise2Cb。输出 &quot;glob2_promise&quot;
7. 调用 `resolve();` 往微任务队列中推了一个任务 `promise2ThenCb`。
8. 到此， 代码执行完毕，调用栈清空。并询问微任务队列是否有值。（此时微任务队列中应该是： [promise1ThenCb, promise2ThenCb]）。
9. 调用栈清空情况下， 取出微任务队列中的第一个任务 `promise1ThenCb`，压入调用栈中，并执行，输出 &quot;glob1_then&quot;。执行完毕， 调用栈弹出 `promise1ThenCb`。（此时调用栈为空， 微任务队列为: [promise2ThenCb]）。
10. 取出微任务队列中的第一个任务 `promise2ThenCb`，压入调用栈中，并执行，输出 &quot;glob2_then&quot;。执行完毕， 调用栈弹出 `promise2ThenCb`。（此时调用栈为空， 微任务队列为: []）。
- 至此， 第一轮事件循环的 TASK阶段 结束， 进入渲染绘制阶段。
  - 第一轮事件循环，控制台的log应该为： 	
  		&quot;glob1&quot;、&quot;glob1_promise&quot;、&quot;glob2_promise&quot;、&quot;glob1_then&quot;、&quot;glob2_then&quot;
 
--- 绘制完成， 开始第二轮事件循环 ---
1.  `Webapis` 将上个循环中的 `timeout1Cb` 和 `timeout2Cb`依次放入任务队列。（为什么会在第二轮循环就放到任务队列了， 是因为 setTimeout 第二个参数没传, 默认为0，就放到下一个循环中去执行了， 如果第二个参数是一个大于16的数， 那这个任务就可能会到下下个循环中去执行）
2. 在调用栈为空的情况下， 取出第一个任务 `timeout1Cb`， 压入调用栈中， 并执行， 输出 &quot;timeout1&quot;
3. 实例化 promise， 传入 `timeout1PromiseCb` 执行器，执行 `timeout1PromiseCb`。输出 &quot;timeout1_promise&quot;
4. 调用 `resolve();` 往微任务队列中推了一个任务 `timeout1ThenCb`。
5. 到此， `timeout1Cb` 代码执行完毕，调用栈清空。并询问微任务队列是否有值。（此时微任务队列中应该是： [timeout1ThenCb]）。
6. 调用栈清空情况下， 取出微任务队列中的第一个任务 `timeout1ThenCb`，压入调用栈中，并执行，输出 &quot;timeout1_then&quot;。执行完毕， 调用栈弹出 `timeout1ThenCb`。（此时调用栈为空， 微任务队列为: []）。
	- 至此， 第二轮事件循环的第一个任务执行完毕(目前任务队列： [timeout2Cb])

7. 在调用栈为空的情况下， 取出第一个任务 `timeout2Cb`， 压入调用栈中， 并执行， 输出 &quot;timeout2&quot;
8. 实例化 promise， 传入 `timeout2PromiseCb` 执行器，执行 `timeout2PromiseCb`。输出 &quot;timeout2_promise&quot;
9. 调用 `resolve();` 往微任务队列中推了一个任务 `timeout2ThenCb`。
10. 到此， `timeout2Cb` 代码执行完毕，调用栈清空。并询问微任务队列是否有值。（此时微任务队列中应该是： [timeout2ThenCb]）。
11. 调用栈清空情况下， 取出微任务队列中的第一个任务 `timeout2ThenCb`，压入调用栈中，并执行，输出 &quot;timeout2_then&quot;。执行完毕， 调用栈弹出 `timeout2ThenCb`。（此时调用栈为空， 微任务队列为: []）。
	- 至此， 第二轮事件循环的第二个任务执行完毕(目前任务队列： [])

- 至此， 第二轮事件循环的 TASK阶段 结束， 开始进入 渲染部分， 依次走 rAF， Style, Layout, Paint。
  - 第二轮事件循环，控制台的log应该为： 
  		&quot;timeout1&quot;、&quot;timeout1_promise&quot;、&quot;timeout1_then&quot;、&quot;timeout2&quot;、&quot;timeout2_promise&quot;、&quot;timeout2_then&quot;
  
--- 绘制完成， 开始第三轮事件循环 ---
1.  `Webapis`  上没有东西交给 任务队列， 所以此时 任务队列为空， 调用栈为空。于是事件循环进入空转状态。并每隔16ms左右 渲染一次页面。


**/

</code></pre>
<h3 id="2-由script-标签分发出来的任务">② 由script 标签分发出来的任务</h3>
<pre><code class="language-html">&lt;script&gt;
  console.log(&quot;script1 - begin&quot;);

  setTimeout(function cb1() {
    console.log(&quot;script1 - timeout1&quot;);
  });

  Promise.resolve().then(function microCb1(){
    console.log(&quot;script1 - then&quot;)
  });

  console.log(&quot;script1 - end&quot;);
&lt;/script&gt;
&lt;script&gt;
  console.log(&quot;script2 - begin&quot;);

  setTimeout(function cb2() {
    console.log(&quot;script2 - timeout1&quot;);
  });

  Promise.resolve().then(function microCb2(){
    console.log(&quot;script2 - then&quot;)
  });

  console.log(&quot;script2 - end&quot;);
&lt;/script&gt;


&lt;!-- 

解析： 
 ----- 第一轮事件循环 ------ 
1. 初始化js环境，将两个script的任务由  `Webapis`  推入 任务队列。（此时任务队列中有两个任务， 分别为对应的的script）
2. 询问调用栈是否为空， 是， 则取任务队列最前面一个， 压入调用栈执行， 任务队列length减1。
3. 执行第一个 script 中的代码。
4. 执行 `console.log(&quot;script1 - begin&quot;);`， 输出 &quot;script1 - begin&quot;
5. 执行 setTimeout 逻辑， 将cb1交与 `Webapis` , 并让 `Webapis` 在满足条件的情况下将cb1推入任务队列。此时是 0 毫秒后，及下一轮事件循环， 也就是当前事件循环结束后。
6. 执行 Promise.resolve 语句， 并向微任务队列推入一个 `microCb1` 的任务
7. 执行 `console.log(&quot;script1 - end&quot;);`， 输出 &quot;script1 - end&quot;
8. 此时代码执行完毕， 询问 调用栈是否为空 的答案为 true， 则开始执行微任务。
9. 取出微任务队列中的第一个任务 microCb1， 压入调用栈， 开始执行。输出 &quot;script1 - then&quot;， microCb1 执行完毕， 弹出调用栈。（如若还有， 继续重复此操作， 直到微任务队列为空）
10. 微任务此时length为0， 调用栈为空。
  - 此任务执行完毕， 依次输出 &quot;script1 - begin&quot;、&quot;script1 - end&quot; 、&quot;script1 - then&quot;

11. 开始执行下一个任务
12. 询问调用栈是否为空， 是， 则取队列最前面一个， 压入调用栈执行， 任务队列length减1， 则当前任务队列length为0。
13. ... 重复 3 - 10 ... 
 - 此任务执行完毕， 依次输出 &quot;script2 - begin&quot;、&quot;script2 - end&quot; 、&quot;script2 - then&quot;

14. 此时，调用栈为空， 且 任务队列为空。于是便走 渲染 阶段， 依次经过 requestAnimationFrame、 Style Calculation、Layout Calculation、 Pint 阶段（看下面 Event Loop 周期组成）
15. 直到 页面绘制完成， 这第一轮 事件循环 算是结束。于是便开始第二轮事件循环

 ----- 第二轮事件循环 ------ 

16. 我们在 script1 和 script2 中有向 `Webapis` 中分发了一个 cb1和 cb2 ， 在上一轮事件循环中它们一直处于  `Webapis` 中， 未到达任务队列。而此时，  `Webapis` 则会把这两个任务交给 任务队列。
17. 询问调用栈是否为空， 得到回复是 true， 则将任务队列中的 cb1 取出， 压入调用栈。（队列的顺序和分发时候的先后顺序保持一致）
18. 执行 cb1， 输出 &quot;script1 - timeout1&quot;。此时任务执行完毕， 调用栈清空。开始执行微任务， 发现没有微任务。OK， 执行下一个任务。
19. ... 重复 17 - 18 两个步骤, 把调用的 cb1 换成了cb2 ...
 - 上面两个任务执行完毕， 依次输出 &quot;script1 - timeout1&quot; 、&quot;script2 - timeout1&quot;

20. 此时，调用栈为空，且任务全部执行完毕（微任务没执行完毕是不会走下一个任务， 所以此处任务执行完毕的前提条件就是微任务全部执行完毕）
21. ... 重复 14 - 15 两个步骤， 至此， 所有任务执行完毕， 事件循环进行空转（虽说是空转， 其实也是每次都会去判断任务队列是否有值， 当有值并且调用栈为空的时候， 就去进行对应的操作， 取任务， 压栈， 执行，出栈...），并每隔 16.6ms 进行一次视图绘制。...


--&gt;

</code></pre>
<h3 id="3-由事件分发的任务-1">③ 由事件分发的任务 - 1</h3>
<pre><code class="language-html">... 
&lt;button id=&quot;btn&quot;&gt;
  按钮
&lt;/button&gt;


&lt;script&gt;
const btn = document.querySelector('#btn');

btn.addEventListener('click', function click1Cb(){
  Promise.resolve().then(function click1ThenCb() {
    console.log('promise1_then')
  })
  console.log('listener1');
})

btn.addEventListener('click', function click2Cb(){
  Promise.resolve().then(function click2ThenCb() {
    console.log('promise2_then')
  })
  console.log('listener2');
})

&lt;/script&gt;

&lt;!--
解析：
1. 获取btn元素。
2. 给btn绑定click事件， 即 把 `click1Cb` 函数交给  `Webapis` ， 当用户点击了 btn 后，  `Webapis` 会将这个 `click1Cb` 推入任务队列。
3. 给btn绑定click事件， 即 把 `click2Cb` 函数交给  `Webapis` ， 当用户点击了 btn 后，  `Webapis` 会将这个 `click2Cb` 推入任务队列。
4. 第一轮事件循环完毕， 进行空转。


--- 一段时间后 ---
用户点击这个按钮。
1.  `Webapis`  得知按钮点击， 便将 `click1Cb` 、`Click2Cb` 依次放入 任务队列中。
2. 事件循环判断当前调用栈是否为空，以及 任务队列 中是否有值。得到true 的结果后，取出任务队列中的第一个任务 `click1Cb`，压入调用栈中，并执行。
3. 执行 `click1Cb`， 首先 分发了一个微任务 `click1ThenCb` 到微任务队列中。接着走下一行的console.log， 输出 &quot;listener1&quot;
4. `click1Cb` 执行完毕， 调用栈弹出 `click1Cb`， 开始执行微任务， 此时微任务队列为： [click1ThenCb]
5. 取出微任务队列中的第一个微任务 `click1ThenCb`， 压入调用栈中， 并执行。输出 &quot;promise1_then&quot;。`click1ThenCb` 执行完毕， 调用栈弹出 `click1ThenCb`
- 至此，调用栈为空， 微任务队列为空。 第一个任务队列中的第一个任务执行完毕。

1. 取出 任务队列 的第一个任务 `click2Cb`，压入调用栈中，并执行。
2. 执行 `click2Cb`， 首先 分发了一个微任务 `click2ThenCb` 到微任务队列中。接着走下一行的console.log， 输出 &quot;listener2&quot;
3. `click2Cb` 执行完毕， 调用栈弹出 `click2Cb`， 开始执行微任务， 此时微任务队列为： [click2ThenCb]
4. 取出微任务队列中的第一个微任务 `click2ThenCb`， 压入调用栈中， 并执行。输出 &quot;promise2_then&quot;。`click2ThenCb` 执行完毕， 调用栈弹出 `click2ThenCb`
5. 至此，调用栈为空， 微任务队列为空。 第一个任务队列中的第一个任务执行完毕。

综上分析， 此demo的输出就是 &quot;listener1&quot;、 &quot;promise1_then&quot;、&quot;listener2&quot;、&quot;promise2_then&quot;
--&gt;



</code></pre>
<h3 id="4-由事件分发的任务-2">④ 由事件分发的任务 - 2</h3>
<pre><code class="language-html">... 
&lt;button id=&quot;btn&quot;&gt;
  按钮
&lt;/button&gt;


&lt;script&gt;
const btn = document.querySelector('#btn');

btn.addEventListener('click', function click1Cb(){
  Promise.resolve().then(function click1ThenCb() {
    console.log('promise1_then')
  })
  console.log('listener1');
})

btn.addEventListener('click', function click2Cb(){
  Promise.resolve().then(function click2ThenCb() {
    console.log('promise2_then')
  })
  console.log('listener2');
})
  
btn.click();

&lt;/script&gt;

&lt;!--
解析：
1. 获取btn元素。
2. 给btn绑定click事件， 即 把 `click1Cb` 函数交给  `Webapis` ， 当用户点击了 btn 后，  `Webapis` 会将这个 `click1Cb` 推入任务队列。
3. 给btn绑定click事件， 即 把 `click2Cb` 函数交给  `Webapis` ， 当用户点击了 btn 后，  `Webapis` 会将这个 `click2Cb` 推入任务队列。
4. btn 自己触发 click 事件, 调用栈压入 btn.click
5. 内部创建事件对象，缺少的数据由默认值填充。（如 鼠标位置信息等）
6. 依次触发事件（注意， 此次是内部js触发， 相当于自己注册事件，自己触发， 不走 `Webapis` ， 更不走任务队列）
7. 调用栈压入 `click1Cb`，执行 `click1Cb`， 此时调用栈：[ btn.click, click1Cb ]
8. 执行 `click1Cb`， 首先 分发了一个微任务 `click1ThenCb` 到微任务队列中。接着走下一行的console.log， 输出 &quot;listener1&quot;。(此时 微任务队列内容为： [click1ThenCb])
9. `click1Cb` 执行完毕， 调用栈弹出 `click1Cb`，此时调用栈内容为：[btn.click]， 因为调用栈非空， 不能执行微任务， 所以， 进行下一个事件监听函数的触发。 
10. 调用栈压入 `click2Cb`，执行 `click2Cb`。此时调用栈：[ btn.click, click2Cb ]
11. 执行 `click2Cb`， 首先 分发了一个微任务 `click2ThenCb` 到微任务队列中。接着走下一行的console.log， 输出 &quot;listener2&quot;。(此时 微任务队列内容为： [click1ThenCb, click2ThenCb])
12. `click2Cb` 执行完毕， 调用栈弹出 `click2Cb`，调用栈内容为：[btn.click]， 此时没有未触发的事件监听函数了， 所以 btn.click 执行完毕， 调用栈弹出 btn.click， 此时调用栈内容为：[]。 
13. 询问调用栈是否为空，并且是否有未执行的微任务。 得到结果为true。便开始执行微任务。
14. 取出微任务队列中的第一个微任务 `click1ThenCb`， 压入调用栈中， 并执行。输出 &quot;promise1_then&quot;。`click1ThenCb` 执行完毕， 调用栈弹出 `click1ThenCb`。
15. 进行下一个微任务执行， 取出微任务队列中的第一个微任务 `click2ThenCb`， 压入调用栈中， 并执行。输出 &quot;promise2_then&quot;。`click2ThenCb` 执行完毕， 调用栈弹出 `click2ThenCb`。此时， 微任务队列执行完毕。
16. 此时，任务队列为空， 且调用栈为空，便进入 渲染阶段， 渲染结束， 第一轮事件循环完毕。开始后面的事件循环。


综上分析， 此demo的输出就是 &quot;listener1&quot;、 &quot;listener2&quot;、&quot;promise1_then&quot;、&quot;promise2_then&quot;
--&gt;



</code></pre>
<p>两个 事件相关的demo总结：</p>
<p>其实第一个和第二个， 代码层面上看， 不同的就是第一个是需要用户与UI交互进行触发， 第二个是通过js触发。</p>
<p>但是从代码执行的时候看， 就会有这么一些区别：</p>
<ol>
<li>通过 UI 交互进行触发， 就会走 <code>Webapis</code> ， 因为dom 的事件监听都是通过 <code>Webapis</code> 来的。而通过 <code>Webapis</code> ， 在事件触发的时候，  <code>Webapis</code> 则会把事件处理函数推入 任务队列， 等待事件循环的调度与执行。</li>
<li>通过js触发， 这里就相当于一个简单的事件系统，一边去 监听， 一边去触发， 同步的操作，没涉及到异步， 更没涉及到 <code>Webapis</code> ， 任务队列。所以， 在触发事件处理函数的时候，调用栈一直都会有一个 btn.click 函数，等到事件处理函数全部执行完毕， 有了返回值。而 btn.click 才算执行结束。并从 调用栈弹出。清空了调用栈， 才能去执行 事件处理函数中 分发的微任务。</li>
</ol>
<p>到此， 事件循环我个人的理解就是这样。这也是我花了几天时间集中精力去理解得来的一个总结。希望对大家能有一些帮助。</p>
<p>另因为这个只是我个人理解， 所以各位看官看的时候当个参考即可。如果发现我的理解和你们的理解有些出入的， 也欢迎在评论里提出来，一起完善各自对 Event Loop 的理解。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">深入：微任务与Javascript运行时环境</a></li>
<li><a href="https://www.jianshu.com/p/12b9f73c5a4f">前端基础进阶（十四）：深入核心，详解事件循环机制</a></li>
<li><a href="https://www.bilibili.com/video/BV1bE411B7ez">【熟肉 | 内核】深入JavaScript中的EventLoop</a></li>
<li><a href="https://www.bilibili.com/video/BV1oV411k7XY">【自制熟肉】Philip Roberts：到底什么是Event Loop呢？（JSConf EU 2014）</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渲染与校验]]></title>
        <id>https://croatiaparanoia.github.io/blog/post/xuan-ran-yu-xiao-yan/</id>
        <link href="https://croatiaparanoia.github.io/blog/post/xuan-ran-yu-xiao-yan/">
        </link>
        <updated>2019-04-28T10:01:07.000Z</updated>
        <content type="html"><![CDATA[<p>当时写这个页面， 对我收获最大的应该是一个FormItem组件的Props设计，以及提交时的每一个FormItem的值校验逻辑。</p>
<p>​UI:</p>
<figure data-type="image" tabindex="1"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755396474.png" alt="" loading="lazy"></figure>
<p>输入&amp;选择的Form列表的数据源</p>
<figure data-type="image" tabindex="2"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755402190.png" alt="" loading="lazy"></figure>
<p>使用数据源：</p>
<figure data-type="image" tabindex="3"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755409906.png" alt="" loading="lazy"></figure>
<p>存储用户录入数据的容器：</p>
<figure data-type="image" tabindex="4"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755415123.png" alt="" loading="lazy"></figure>
<p>校验函数：</p>
<figure data-type="image" tabindex="5"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755425140.png" alt="" loading="lazy"></figure>
<p>使用校验函数：</p>
<figure data-type="image" tabindex="6"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755431372.png" alt="" loading="lazy"></figure>
<p>此方式，</p>
<p>一个重点是数据驱动视图， FormItem 的样子， 由props的数据控制。</p>
<p>第二个则是 rules这个校验规则。</p>
<p>如果在以前要判断这些数据是否合法， 需要一个个的写if来判断， 判断得多的话， 基本都是一整页都是if代码</p>
<p>而如果使用rules + 校验函数， 则值需要几行代码， 循环计算然后，抛出有误的提示语句，并大大简洁了代码。</p>
<p>此方式借鉴了 Ant Design 的 <a href="%5Bhttps://ant.design/components/form-cn/#%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99%5D(https://ant.design/components/form-cn/#%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99)">规则校验 | 表单 Form  - Ant Design</a></p>
<p>以及看到别人推荐的一个校验器 <a href="https://github.com/fjc0k/vtils#easyvalidator">fjc0k/vtils: 小巧实用的 JavaScript 工具类库</a></p>
]]></content>
    </entry>
</feed>