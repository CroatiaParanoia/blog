<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://croatiaparanoia.github.io/blog/</id>
    <title>🦌</title>
    <updated>2021-01-05T05:20:00.093Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://croatiaparanoia.github.io/blog/"/>
    <link rel="self" href="https://croatiaparanoia.github.io/blog/atom.xml"/>
    <subtitle>万物皆有裂痕，那是光照进来的地方。</subtitle>
    <logo>https://croatiaparanoia.github.io/blog/images/avatar.png</logo>
    <icon>https://croatiaparanoia.github.io/blog/favicon.ico</icon>
    <rights>All rights reserved 2021, 🦌</rights>
    <entry>
        <title type="html"><![CDATA[70道js面试题理解]]></title>
        <id>https://croatiaparanoia.github.io/blog/post/70-dao-js-mian-shi-ti-li-jie/</id>
        <link href="https://croatiaparanoia.github.io/blog/post/70-dao-js-mian-shi-ti-li-jie/">
        </link>
        <updated>2021-01-05T05:16:53.000Z</updated>
        <content type="html"><![CDATA[<p>此文章是根据 <a href="https://juejin.cn/post/6913534577684414472">70 道 Javascript 面试题【译】</a> 的题目， 自己的理解所写出来的。</p>
<p>欢迎大家在下面留下不同想法。</p>
<h2 id="1undefined-和-null-有什么区别">1.undefined 和 null 有什么区别？</h2>
<blockquote>
<p>undefined 是未指定特定值的变量的默认值，或者没有显式返回值的函数。</p>
</blockquote>
<p>未定义，没有预设过该值， 比如访问一个对象不存在的属性。</p>
<blockquote>
<p>null 是『不代表任何值的值』</p>
</blockquote>
<p>表示该值是有的， 只不过不是正常的返回结果。比如 通过 <code>getElementById</code> 查询一个不存在的元素， 该方法可以肯定有一个返回值， 返回的是匹配结果， 而又因为根据选择器不一定能匹配到元素， 存在为空的情况， 所以， 就应该使用一个  null  去作为一个返回值， 表示有一个结果， 只不过是为空的。</p>
<h2 id="2-运算符">2. &amp;&amp; 运算符</h2>
<p>逻辑与， 属于短路运算符的一种。 当 A &amp;&amp; B ， A 位置结果为真值时， 则会取B位置的结果作为运算结果， 否则取A位置的结果作为运算结果。</p>
<p>注意：</p>
<p>当 <code>fn1() &amp;&amp; fn2()</code> 这样时， 首先是执行 fn1 函数， 得到返回值后， 根据返回值对应的布尔值， 再来决定是否会走到后面的 <code>fn2()</code> ， 如果fn1 函数执行结果为假值， 则不会执行fn2。因为 &amp;&amp; 运算符已经得到了一个结果了。</p>
<h2 id="3-运算符能做什么">3. || 运算符能做什么</h2>
<p>逻辑或，短路运算符的一种。 当有 A || B， A位置的结果为假时， 则会取B位置的结果作为运算结果， 否则取A位置的结果作为运算结果。</p>
<p>此运算符通常除了条件计算， 还有一个应用场景就是 取默认值， 如下</p>
<pre><code class="language-javascript">const defaultValue = { ... };

function fn(inputValue){
  const v = inputValue || defaultValue;
  ...
}

</code></pre>
<p>注意， &amp;&amp; 和 || 两个运算符， 都是将值进行 <code>Boolean</code> 运算后的结果，再去进行与和或的运算的，也就是说， 在上面例子中 ，如果inputValue 传入的是 0， NaN,  null， ''， undefined， false （也就是 21题所说的 <strong>虚值</strong>）， 都会走到 后面的 <code>defaultValue</code> 中</p>
<h3 id="4-使用-或一元加运算符是将字符串转换为数字的最快方法吗">4. 使用 + 或一元加运算符是将字符串转换为数字的最快方法吗？</h3>
<blockquote>
<p>根据MDN文档，<code>+</code>是将字符串转换为数字的最快方法，因为如果值已经是数字，它不会执行任何操作。</p>
</blockquote>
<p>但是个人认为， 使用隐式转换的方法， 会给代码的可读性带来一定的影响， 如果可以， 尽量使用直观的数据类型转换， 让读者可以很肯定的知道，该语句返回的数据类型是什么。</p>
<p>当然， 如果还是想用 这些符号， 也可以考虑封装基础的转换函数， 如：</p>
<pre><code class="language-javascript">function toNumber(v){
  return +v;
}


+a // =&gt;
toNumber(a);
</code></pre>
<p>既满足了想用 + 操作符的心理， 又有了可读性。</p>
<h2 id="5-dom-是什么">5. DOM 是什么？</h2>
<p>Document Object Model 的简写，表示 <strong>文档对象模型</strong> 。 浏览器在拿到html文件后， 会去解析里面的html标签，并创建出一个树状结构来表现这个html的嵌套， 属性等一些信息。</p>
<p>并同时会交于js 一个 document 的全局对象，通过这个对象， js就可以来操控这个树状结构。（赋予js操控dom 的能力）</p>
<h2 id="6-什么是事件传播">6. 什么是事件传播?</h2>
<p>当一个元素触发某个事件， 首先会从 window 开始， 自顶向下的依次触发，此阶段为捕获阶段， 由外到里。</p>
<p>当到达目标元素时， 则是为 目标阶段。真正触发该元素的该事件。</p>
<p>触发目标元素的事件完毕后， 再从目标元素开始，自底向上的依次触发， 到window为止， 此阶段为冒泡阶段， 由里到外</p>
<blockquote>
<p>事件传播有三个阶段：</p>
<ol>
<li><strong>捕获阶段</strong>–事件从 <code>window</code> 开始，然后向下到每个元素，直到到达目标元素。</li>
<li><strong>目标阶段</strong>–事件已达到目标元素。</li>
<li><strong>冒泡阶段</strong>–事件从目标元素冒泡，然后上升到每个元素，直到到达 <code>window</code>。</li>
</ol>
</blockquote>
<h2 id="7-什么是事件冒泡">7. 什么是事件冒泡？</h2>
<p>当<strong>事件</strong>发生在<strong>DOM</strong>元素上时，事件自底向上的触发， 首先是目标元素触发，再是目标元素的父级元素， 祖父级元素，依次上推，到window触发后为止。</p>
<h3 id="8-什么是事件捕获">8. 什么是事件捕获？</h3>
<p>当<strong>事件</strong>发生在<strong>DOM</strong>元素上时，事件自顶向下的触发， 首先是 window 触发，自顶向下依次触发， 到达目标元素触发后为止。</p>
<h3 id="9-eventpreventdefault-和-eventstoppropagation方法之间有什么区别">9. event.preventDefault() 和 event.stopPropagation()方法之间有什么区别？</h3>
<p>event.preventDefault() 阻止事件的默认行为， 比如 a 标签的点击跳转， button[type=submit] 的点击刷新页面等默认行为</p>
<p>event.stopPropagation() 阻止冒泡 或者 捕获阶段， 终止由外到内的捕获， 或者由内到外的冒泡。</p>
<h3 id="10-如何知道是否在元素中使用了eventpreventdefault方法">10. 如何知道是否在元素中使用了<code>event.preventDefault()</code>方法？</h3>
<blockquote>
<p>我们可以在事件对象中使用<code>event.defaultPrevented</code>属性。它返回一个布尔值用来表明是否在特定元素中调用了<code>event.preventDefault()</code>。</p>
</blockquote>
<h3 id="11-为什么此代码-objsomepropx-会引发错误">11. 为什么此代码 <code>obj.someprop.x</code> 会引发错误?</h3>
<pre><code class="language-javascript">const obj = {};

console.log(obj.someprop.x);



// 一层一层的递进，  首先 可以将 obj.someprop.x 分解成  obj.someprop 和 someprop.x

const someprop = obj.someprop; // 此时可以确定 someprop 是undefined。

someprop.x // =&gt; 此时就对应了 undefined.x ， 自然就会报错了。
</code></pre>
<h2 id="12-什么是-eventtarget">12. 什么是 event.target ？</h2>
<p>触发事件的目标元素。 如有结构 div &gt; button， div 绑定点击事件， 点击button， 则会冒泡至div， 触发div的点击事件，但是此时 事件对象中的target 是指的 button 元素， 因为button 是事件触发的目标元素。</p>
<h2 id="13-什么是-eventcurrenttarget">13. 什么是 event.currentTarget？？</h2>
<p>绑定了该事件的元素。如有结构 div &gt; button， div 绑定点击事件， 点击button， 则会冒泡至div， 触发div的点击事件，但是此时 事件对象中的target 是指的 button 元素， 因为button 是事件触发的目标元素。而事件对象中的 currentTarget 就是指向了div， 因为div是绑定了该事件的元素。</p>
<h3 id="14-和-有什么区别">14. == 和 === 有什么区别？</h3>
<p>“==” 首先进行类型的判断， 如果统一， 则直接进行值的判断。（如果是引用类型则比较引用的内存地址）。如果类型不统一， 则首先进行数据类型的转换， 统一了两边数据类型后，再进行比较。</p>
<p>“===” 首先比较类型， 类型不一样就返回false了， 如果类型一样再比较值或者引用地址。不会进行隐式数据类型转换。</p>
<h3 id="15-为什么在-js-中比较两个相似的对象时返回-false">15. 为什么在 JS 中比较两个相似的对象时返回 false？</h3>
<p>先看下面的例子：</p>
<pre><code class="language-javascript">let a = { a: 1 };  
let b = { a: 1 };  
let c = a;  
console.log(a === b); // 打印 false，即使它们有相同的属性  
console.log(a === c); // true  
</code></pre>
<p>js 区分了基本数据类型和复杂数据类型。 而基本数据类型的一大特性就是按值存储， 复杂数据类型则是按引用存储。及， 当进行比较时， 基本数据类型是拿出自己的值， 而复杂数据类型则是拿出自己所在内存中的引用地址， 两者进行比较。</p>
<p>而此例子中， 则是涉及到复杂数据类型的创建， 每创建一个复杂数据类型， js 都会在堆内存中开辟一块空间来对这块的数据进行存储， 并将该内存空间的地址， 作为该语句的返回值（此处就是 字面量形式创建的对象）。</p>
<p>所以 第一行代码的流程是：</p>
<ol>
<li>声明变量a，</li>
<li>通过对象字面量来创建一个新的对象
<ol>
<li>创建这个对象， 首先就在堆内存中开一块空间， 用来表示该对象的存储空间。</li>
<li>将对象中的键值对数据， 置入 该内存空间。</li>
<li>将该内存空间的内存地址， 作为该语句( <code>{a: 1}</code> )的结果， 返回出去 。</li>
</ol>
</li>
<li>此时， 变量a 就接收到了一个内存地址， 该内存地址就是指向了第二步所创建出来的内存空间。</li>
</ol>
<p>然后到第二行， 代码流程同上， 创建了一个完全新的内存空间， 返回了一个完全新的内存地址交给变量b。</p>
<p>第三行， c = a， 此时则是将 a 存储的内存地址， 复制一份， 交给c，此时c 里面存的也是第一行创建的那块内存空间的内存地址。</p>
<p>第四行，<code>console.log(a === b)</code> ， 此时的比较， 则是比较两者的引用地址， 因 两者存放的引用地址并不一致， 所以返回false。</p>
<p>第五行， <code>console.log(a === c)</code> ，此时的比较， 也是比较两者的引用地址， 因为 c 的地址是从a 复制过来的， 所以，c 的地址就是完全等于 a的地址， 故两者一致， 返回true。</p>
<h3 id="16-运算符能做什么">16. !! 运算符能做什么？</h3>
<p>两次取反， 相当于转换为布尔值， 不过个人还是喜欢 Boolean 函数来进行布尔值的转换。</p>
<h3 id="17-如何在一行中计算多个表达式的值">17. 如何在一行中计算多个表达式的值？</h3>
<p>利用圆括号的返回值就是最后一个值的特性， 另外的还有一些写法：</p>
<pre><code class="language-javascript">const arr = ['name', 'nick', 'des'];

// 如果初始化一个对象， key 为上面数组的的每一项。

function arrToObject(arr, normalValue){
  
  // 正常情况下使用reduce，可能得这样写
  return arr.reduce((r, key)=&gt;{
    r[key] = normalValue;
    return r;
  }, {})
  
  // 但是， 如果使用圆括号
  return arr.reduce((r, key) =&gt; (r[key] = normalValue, r), {});
}





// 再就是更改this指向了
const obj = {
  innerWidth: 2333,
  getInnerWidth(){
    return this.innerWidth;
  }
}

obj.getInnerWidth(); // 2333,
(0, obj.getInnerWidth)(); // 是2333 吗
</code></pre>
<h3 id="18-什么是提升">18. 什么是提升？</h3>
<blockquote>
<p><strong>提升</strong>是用来描述变量和函数移动到其(全局或函数)作用域顶部的术语。</p>
</blockquote>
<p>这里觉得应该是 描述 <strong>变量声明</strong> 和 <strong>函数声明</strong>， 移动到当前作用域顶部的术语。</p>
<p>在预解析阶段， 会把带 <code>var</code> 或 <code>function</code> 关键字的声明提升到该作用域的顶部。</p>
<p>而在执行阶段， 就只是将变量进行赋值。</p>
<p>如下例子:</p>
<pre><code class="language-javascript">function fn(){};
var fn = 1;

var cb = 2;
function cb(){};



// =&gt; 变量提升
function fn(){}; 
var fn; 
var cb;
function cb(){};

// =&gt; 开始执行
// 此处的 function fn(){} 的声明因为提升到预解析的时候声明了， 所以此处跳过函数的fn的声明, 直接到fn 的赋值。
fn = 1;

// 直接  cb 的赋值。
cb = 2;

</code></pre>
<p>注意： 预解析中的变量提升， 只是针对 var 和 function 关键字的声明。</p>
<p>如果是使用let  或者 const的话</p>
<pre><code class="language-javascript">console.log(num); // num is not defined

const num = 123;

{
	console.log(num); // Cannot access 'num' before initialization
  const num = 124;
}

// 从上可以看出， const 不支持预解释， 变量的使用必须在声明的后面。而在私有作用域中， 提前使用未声明的变量时， 则会报出和在全局不一样的错误。 

</code></pre>
<p>此处具体可看 暂存死区</p>
<h3 id="19-什么是作用域">19. 什么是作用域？</h3>
<p>JavaScript 中的作用域是我们可以有效访问变量或函数的区域。JS 有三种类型的作用域：<strong>全局作用域</strong>、<strong>函数作用域</strong>和<strong>块作用域(ES6)</strong>。</p>
<ul>
<li>全局作用域， 在全局作用域中声明的变量或者函数存在于全局作用域中， 在任何作用域中都能访问到它们。</li>
<li>函数作用域， 函数在声明的时候， 会将当前作用域的作用域链存储在自己的 [[Scopes]] 属性中， 而在函数执行的时候， 会产生一个新的私有作用域， 然后再取出自己 [[Scopes]] 中存储的作用域链， 将新的作用域推入该作用域链的最前端， 产出一个新的作用域链。</li>
<li>块级作用域， 在 <code>{}</code> 中通过 let 或 const 声明的变量，只能在其中访问。</li>
</ul>
<p>通过上面对作用域，作用域链的描述。我们可以理解下， 在一个函数作用域中， 查找一个变量的过程。</p>
<pre><code class="language-javascript">var a = 1;
function fn(){
  var b = 2;
  
  function cb (){
    var c = 3;
    console.log(b)
  };
  
  cb();
}

fn();

// =&gt; 代码依次往下， 在全局作用域声明了一个 a， 存值为1；
// =&gt; 然后声明了一个函数fn， 然后将全局的作用域， 塞入了自己的 [[Scopes]] , 此时作用域链为： [{a: 1, ...window}]
// =&gt; 执行fn(), 创建私有作用域，然后拿出fn自己的 [[Scopes]] 属性中的作用域链， 将新产生的私有作用域置入作用域链的最前端， 产出新的作用域链。 并执行fn 中的声明执行完毕， 此时的作用域链中有 [{ b: 2 }, {a: 1, ...window}]。
// =&gt; 然后声明了一个函数 cb， 将当前的作用域链， 作为自己的 [[Scopes]]， 此时的作用域链为： [{ b: 2 }, {a: 1, ...window}]。
// =&gt; 执行 cb()， 创建私有作用域， 然后拿出 cb 自己的 [[Scopes]] 属性中的作用域链， 将新产生的私有作用域置入作用域链的最前端， 产出新的作用域链。此时的作用域链大致为 [{c: 3}, {b: 2}, {a: 1, ...window}]。 然后在 cb 中读取 b 的值， 优先在 [[Scopes]][0] 中查找， 未找到， 然后在 [[Scopes]][1] 中查找... 依次往后，直到 window 为止。

</code></pre>
<p>综上， 一个变量的查找规则就是如此。</p>
<p>现在自身作用域查找， 未找到就上层作用域查找，直到window 为止， 找到则返回值， 没找到则报未定义。</p>
<p>所以， 对此问题， 以前有些性能优化书上有建议， 多次用到的外层作用域变量， 尽量在当前作用域缓存下来以减少变量的查找。</p>
<blockquote>
<p>这块具体可以看看高程第四章的 作用域， 作用域链，变量对象和活动对象</p>
</blockquote>
<p>（对象属性和方法的查找规则也一样，只不过是根据原型和原型链来的）</p>
<h2 id="20-什么是闭包">20. 什么是闭包？</h2>
<p>个人理解：</p>
<p>函数在执行的过程中， 产生了私有作用域， 该私有作用域保护内部的变量不受外界干扰。并同时在<strong>内部创建的复杂数据类型被外界所引用</strong>（不管是return 出去被引用， 还是副作用形式的被外界引用）， 都会导致该函数执行完毕后无法回收内部的变量对象， 无法销毁该作用域， 形成了一个临时性的存储单元。</p>
<p>如：</p>
<pre><code class="language-javascript">
function fn(){
  return [];
}

const v = fn(); // 此时 fn 执行一次产生的作用域就无法被销毁。 这是通过返回值的形式。

// -------------

let v;
function fn(){
  v = [];
}
fn(); // 此时 fn 执行一次产生的作用域就无法被销毁。 这是通过加入副作用， 直接内部创建并赋值给外界变量。


// ------------

let v;
let arr = []
function fn(){
  v = arr;
}

fn(); // 猜一下， 这样是否会形成闭包？

// ------------

let arr = []
function fn(){
  return arr;
}

const v = fn(); // 还有这个呢
</code></pre>
<p>对于上面这几题能理解的话， 基本也就能理解 作用域链，变量对象了，垃圾回收了。 以及在函数内部声明的变量， 都去哪了。还有 arguments 从哪来。</p>
<h3 id="21-javascript-中的虚值是什么">21. JavaScript 中的虚值是什么？</h3>
<blockquote>
<p>const falsyValues = ['', 0, null, undefined, NaN, false];</p>
<p>简单的来说虚值就是是在转换为布尔值时变为 <code>false</code> 的值。</p>
</blockquote>
<h3 id="22-如何检查值是否虚值">22. 如何检查值是否虚值？</h3>
<blockquote>
<p>使用 <code>Boolean</code> 函数或者 <code>!!</code> 运算符。</p>
</blockquote>
<p>个人感觉还是喜欢使用 <code>Boolean</code></p>
<h3 id="23-use-strict-是干嘛用的">23. 'use strict' 是干嘛用的？</h3>
<p>太长直接看原文：</p>
<p><a href="https://juejin.cn/post/6913534577684414472#heading-22">'use strict' 是干嘛用的？</a></p>
<h3 id="24-javascript-中-this-值是什么">24. JavaScript 中 <code>this</code> 值是什么？</h3>
<p><code>this</code> 值的确定，通常要看其使用场景。（以下所讲的函数， 都由 function 创建的普通函数， 而非箭头函数）</p>
<p>在全局作用域中， 非严格模式下， <code>this</code> 指向的 <code>window</code>。严格模式下 <code>this</code> 指向的 <code>undefined</code>。</p>
<p>在函数作用域中， 此时， 又分了几种使用场景（非严格模式）。</p>
<ol>
<li>函数直接调用， 如 <code>fn()</code> ， 此时 <code>fn</code> 中的 <code>this</code> 指向全局。</li>
<li>作为某个对象的方法使用， 如 <code>o.fn()</code> ， 此时， <code>fn</code> 中的 <code>this</code> 指向 <code>o</code></li>
<li>作为构造函数使用， 如 <code>new fn()</code> ， 此时 <code>fn</code> 中的 <code>this</code> 指向新创造出来的实例。</li>
<li>作为 立即执行函数 使用， 如 <code>(function(){})()</code> ， 里面的 <code>this</code> 指向了全局</li>
<li>通过call 或者 apply 来调用， 如果传入的是非 <code>null</code> 和 <code>undefined</code> 的基本数据类型， <code>this</code> 则会指向其对应的包装类型， 否则， this 就会指向 <code>window</code></li>
</ol>
<p>注意： 当为严格模式下， 非严格模式下 <code>this</code> 指向全局的情况， 将会变成 <code>this</code> 指向 <code>undefined</code></p>
<h3 id="25-对象的-prototype原型-是什么">25. 对象的 prototype(原型) 是什么？</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Polyfill]]></title>
        <id>https://croatiaparanoia.github.io/blog/post/polyfill/</id>
        <link href="https://croatiaparanoia.github.io/blog/post/polyfill/">
        </link>
        <updated>2020-11-11T11:03:25.000Z</updated>
        <content type="html"><![CDATA[<h1 id="听闻你这包不愿给我加polyfill">听闻你这包不愿给我加polyfill？</h1>
<figure data-type="image" tabindex="1"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758259689.jpg" alt="" loading="lazy"></figure>
<p>曾经有写了个工具库发到了npm， 最近有位老哥说这个库低版本浏览器不兼容， 如 数组的 includes 方法之类的。我随即看了下，确实吼， tsc 只是把语法糖的转译了， 至于高级API特性的，还是那个样子。</p>
<p>随即准备给库加polyfill， 但是想了下。 嘿， 这第三方库的， 我要是加了polyfill， 那要是有其他人不考虑浏览器兼容性问题的呢， 那岂不是polyfill得代码都用不到， 徒增体积？</p>
<figure data-type="image" tabindex="2"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758267270.jpg" alt="" loading="lazy"></figure>
<p>那好勒， 既然这第三方库不打算整合polyfill， 那就是让使用方去用babel转译这个第三方库了。但是第三方行不行呢， 我心里还真发怵，也不敢直接跟人家说，本着毛主席的“没有调查就没有发言权”原则， 我决定自己去 try 一 try。</p>
<h2 id="随便搞个项目">随便搞个项目</h2>
<p>首先， 那就是项目基础了。</p>
<pre><code class="language-shell">mkdir support-ie

cd support-ie

npm init -y

yarn add webpack webpack-cli --dev

# 装上我那个可怜的包
yarn add ffformat

# 装上 babel 相关依赖
yarn add @babel/core @babel/preset-env @babel/plugin-transform-run-time babel-loader --dev

# 装上 core-js。 按需引入 polyfill 之类的就取这里面的了
yarn add core-js

# 创建 webpack 配置文件
touch webpack.config.js

# 创建 babel 配置文件 
touch babel.config.json

# 源代码文件
mkdir src &amp;&amp; cd src &amp;&amp; touch main.js
</code></pre>
<p>文件创建的差不多，然后就是配制 config 文件了</p>
<pre><code class="language-javascript">// webpack.config.js
const path = require(&quot;path&quot;);

module.exports = {
  entry: {
    main: &quot;./src/main.js&quot;,
  },
  output: &quot;/dist/main.js&quot;,
  module: {
    rules: [
      {
        test: /\.js$/,
        loader: &quot;babel-loader&quot;,
        include: [
          path.resolve(__dirname, &quot;./src&quot;),
          // 这里要把第三方包加入到include中， 不然loader不会去转译
          path.resolve(__dirname, &quot;node_modules/ffformat&quot;),
        ],
      },
    ],
  },
  optimization: {
    minimize: false,
  },
};
</code></pre>
<p>接着是babel 的配置文件</p>
<pre><code class="language-json">// babel.config.json
{
  &quot;presets&quot;: [
    [
      &quot;@babel/env&quot;,
      {
        // 指明 corejs 的版本，（不同版本的文件和命名方式有区别，避免找文件报错， 所以要指明版本）
        &quot;corejs&quot;: 3,
        // 兼容ie9
        &quot;targets&quot;: {
          &quot;ie&quot;: 9,
        },
        // 使用这个按需引入polyfill
        &quot;useBuiltIns&quot;: &quot;usage&quot;
      }
    ]
  ]
}
</code></pre>
<p>紧接着，我们开始在 <code>src/main.js</code> 写上一段代码</p>
<pre><code class="language-javascript">// src/main.js
import * as ffformat from 'ffforamt';

console.log(ffformat);
</code></pre>
<p>然后根目录运行webpack一次 **<code>npx webpack</code> **</p>
<p>就可以看到 打包 <code>main.js</code> 的时候， 引入了一些 <code>core-js</code> 下面的模块， 去看 dist/main.js ， 就能看到针对一些高级特性， 有做了 polyfill。</p>
<p>致此， 正常流程完。</p>
<figure data-type="image" tabindex="3"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758276421.jpg" alt="" loading="lazy"></figure>
<h2 id="遇到的问题">遇到的问题</h2>
<h3 id="1-babel-配置文件的问题">1. Babel 配置文件的问题</h3>
<p>刚开始的时候， 用的是 <code>.babelrc</code> 来配置babel， 结果loader 一直不走 <code>node_modules</code> ， 不转译 <code>node_modules</code> 中的代码，卡了半天，不断找文章，后来发现了一位老哥的话。</p>
<figure data-type="image" tabindex="4"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758282188.png" alt="" loading="lazy"></figure>
<p>随即将 <code>.babelrc</code>  重命名为 <code>babel.config.json</code>， 再 <code>npx webpack</code> ， 成功给 <code>node_modules</code> 中的 <code>ffformat</code> 整入 <code>polyfill</code> 部分的代码。看到这个结果差点把我送走。 这卡了半天的问题， 改了个名字就好了。。。</p>
<figure data-type="image" tabindex="5"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758287255.jpeg" alt="" loading="lazy"></figure>
<h3 id="2-多种polyfill方式">2. 多种polyfill方式</h3>
<ol>
<li>
<p>按需引入方式， 用到哪个高级特性， 就自动加入这个特性的polyfill。 （即 本文写的方式）</p>
</li>
<li>
<p>全量引入方式。在入口文件顶部加入这两行。</p>
<pre><code class="language-javascript">import &quot;core-js/stable&quot;;
import &quot;regenerator-runtime/runtime&quot;;
</code></pre>
</li>
<li>
<p>动态引入方式。这个是在 <a href="https://polyfill.io">polyfill.io</a> 去配置一个外链。配置需要兼容的es版本 或者 需要的对应api。然后 用 script 标签引入该外链， 就会返回对应的一些<code>polyfill</code>代码。（因 script 的src 属于get请求， 所以服务器那边可以知道我们浏览器的 userAgent， 然后根据这个去判断我们浏览器， 给浏览器响应对应的polyfill。 所以用高版本浏览器去访问此请求， 可能返回的内容是空的）</p>
</li>
</ol>
<p>三种方式， 感觉第一种和第三种偏好一点。</p>
<p>第一种的按需引入， 不会因为就一个 高级特性的api， 就导致整个bundle文件瞬间增大N多倍。</p>
<p>第三种则是 指定es版本， 由服务器决定需要返回哪些polyfill。这样相当于是将所有的polyfill 都抽离出去，用别人家的cdn引入进来。</p>
<p>至于选择上， 如果说 请求 <a href="https://polyfill.io">polyfill.io</a> 的速度过慢， 或者项目内网部署，那么选择第一种方式是更好的。</p>
<p>而如果项目可以访问外网资源。并且访问 <a href="https://polyfill.io">polyfill.io</a> 外链速度足够快， 那么用第三种也是极好的。</p>
<p>当然，  如果项目没有涉及到 <code>webpack</code>， <code>rollup</code>之类的构建工具， 只是纯的项目，那么只能选择第三种了。</p>
<p>如果没用 构架工具， 还要内网部署， 那就把外链的 polyfill 下载下来，放到本地再一并部署上去。</p>
<figure data-type="image" tabindex="6"><img src="https://croatiaparanoia.github.io/blog//post-images/1609758295721.jpg" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Event Loop]]></title>
        <id>https://croatiaparanoia.github.io/blog/post/event-loop/</id>
        <link href="https://croatiaparanoia.github.io/blog/post/event-loop/">
        </link>
        <updated>2020-10-02T10:20:39.000Z</updated>
        <content type="html"><![CDATA[<h2 id="任务分发器">任务分发器</h2>
<p>一般的， 下面这些<strong>标签或者API</strong>都可以让一些任务<strong>间接</strong>的进入各自的队列。</p>
<p>任务：script、setTimeout、setInterval，DOM事件绑定， 请求响应等</p>
<p>微任务：promise</p>
<h2 id="event-loop-周期组成">Event Loop 周期组成</h2>
<ol>
<li>
<p>TASK 阶段 （重点就在这）</p>
<ul>
<li>任务调度和执行。 任务中代码执行完毕，调用栈清空后，开始执行微任务队列中的微任务。循环如此， 直至没有微任务，开始下一个任务。如果没有下一个任务， 则进入rAF。</li>
</ul>
</li>
<li>
<p>rAF(<strong>r</strong>equest<strong>A</strong>nimation<strong>F</strong>rame)阶段 - 所有任务执行完毕之后， 页面渲染之前。</p>
</li>
<li>
<p>Style  阶段 - 样式计算， 计算应用到元素上的样式。</p>
</li>
<li>
<p>Layout  阶段 - 创建渲染树， 找出页面上的所有内容及位置。</p>
</li>
<li>
<p>Paint  阶段 - 绘制内容到页面上。</p>
</li>
</ol>
<p>总的来分的话， 可以将上面五个阶段化为两个：</p>
<ol>
<li>TASK 阶段， 主要就是<strong>任务的调度和执行</strong>。 <code>Webapis</code> 推任务到任务队列，事件循环在合适的时候 将任务取出压入调用栈执行和弹出。</li>
<li>渲染绘制阶段，从2到4， 主要就是 绘制前的逻辑执行， 以及视图相关的绘制了。</li>
</ol>
<p>注：微任务的执行，取决于调用栈。调用栈为空才会执行微任务。</p>
<figure data-type="image" tabindex="1"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755671039.png" alt="轨迹图" loading="lazy"></figure>
<h2 id="个人理解的事件循环的一个流程">个人理解的事件循环的一个流程</h2>
<ol>
<li>事件循环不断的判断 任务队列是否有值， 并且调用栈为空。（同时会在每隔16毫秒左右去进行一次视图绘制）</li>
<li><code>Webapis</code>  得到任务， 并在合适的时候将任务推入任务队列。</li>
<li>当有任务队列有值， 并且调用栈查询到的状态为空。则从任务队列中<strong>取出第一个任务</strong>， 压入调用栈，并开始执行该任务。（此时该任务在调用栈最底部）
<ol>
<li>任务代码执行时， 可能会分发新的任务， 比如设置定时器， 发起网络请求，监听事件这些操作。这些都会交与 <code>Webapis</code> 。 当定时器时间满足， 请求响应回来， 监听到事件这些时候，***<code>Webapis</code>  会在下一轮事件循环， 将这些满足条件的任务推入任务队列，等待事件循环的调度。***</li>
<li>任务代码执行时， 可能会分发新的微任务， 如 Promise.resolve().then(cb) 这种的， 此时，将cb函数交推入微任务队列。等待事件循环的调度。</li>
<li>当该任务中代码执行完毕后， 弹出任务，调用栈清空。</li>
<li>判断微任务队列是否有值， 如果有，则从中取出第一个微任务， 压入调用栈并执行，执行完毕 弹出。（反复此操作， 直至微任务队列为空）</li>
<li>当微任务队列为空， 且调用栈已清空时， 则开始下一个任务。</li>
</ol>
</li>
<li>重复第三条，直至任务队列为空， 且调用栈为空。</li>
<li>进入 渲染绘制 阶段， 依次调用 requestAnimationFrame 队列中的任务（此任务中进行分发任务和微任务， 参考3-1 到 3-5）。然后进入 <strong>Style Calculation</strong>、<strong>Layout Calculation</strong>、<strong>Paint</strong> 阶段。完成后开始新的一轮事件循环。（对于新的一轮事件循环判定的标准是 <strong>走过了 渲染绘制 阶段</strong>）</li>
<li>每轮 事件循环 开始时， 如果调用栈为空并且任务队列有值， 就会走上面的 第三到第五条的流程。</li>
<li>如果调用栈为空， 并且任务队列也为空， 则事件循环会进入空转状态（每隔16毫秒左右进行一次视图绘制， 即 每隔16ms 会走一次第五条）。</li>
</ol>
<h2 id="测试demo">测试Demo</h2>
<h3 id="1-由-settimeout-分发出来的任务">① 由 setTimeout 分发出来的任务</h3>
<pre><code class="language-javascript">console.log(&quot;glob1&quot;);

setTimeout(function timeout1Cb() {
  console.log(&quot;timeout1&quot;);
  new Promise(function timeout1PromiseCb(resolve) {
    console.log(&quot;timeout1_promise&quot;);
    resolve();
  }).then(function timeout1ThenCb() {
    console.log(&quot;timeout1_then&quot;);
  });
});

new Promise(function promise1Cb(resolve) {
  console.log(&quot;glob1_promise&quot;);
  resolve();
}).then(function promise1ThenCb() {
  console.log(&quot;glob1_then&quot;);
});

setTimeout(function timeout2Cb() {
  console.log(&quot;timeout2&quot;);
  new Promise(function timeout2PromiseCb(resolve) {
    console.log(&quot;timeout2_promise&quot;);
    resolve();
  }).then(function timeout2ThenCb() {
    console.log(&quot;timeout2_then&quot;);
  });
});

new Promise(function promise2Cb(resolve) {
  console.log(&quot;glob2_promise&quot;);
  resolve();
}).then(function promise2ThenCb() {
  console.log(&quot;glob2_then&quot;);
});

/**
解析：
1. 代码开始执行， 第一个 log 是 &quot;glob1&quot; 无疑。
2. 执行 `setTimeout(timeout1Cb)`， 将 `timeout1Cb` 交与 ` `Webapis` `， 等待 ` `Webapis` ` 在下一轮事件循环推入 任务队列。
3. 实例化 promise， 传入 promise1Cb 执行器，执行 promise1Cb。输出 &quot;glob1_promise&quot;
4. 调用 `resolve();` 往微任务队列中推了一个任务 `promise1ThenCb`。
5. 执行 `setTimeout(timeout2Cb)`， 将 `timeout2Cb` 交与 ` `Webapis` `， 等待 ` `Webapis` ` 在下一轮事件循环推入 任务队列。
6. 实例化 promise， 传入 promise2Cb 执行器，执行 promise2Cb。输出 &quot;glob2_promise&quot;
7. 调用 `resolve();` 往微任务队列中推了一个任务 `promise2ThenCb`。
8. 到此， 代码执行完毕，调用栈清空。并询问微任务队列是否有值。（此时微任务队列中应该是： [promise1ThenCb, promise2ThenCb]）。
9. 调用栈清空情况下， 取出微任务队列中的第一个任务 `promise1ThenCb`，压入调用栈中，并执行，输出 &quot;glob1_then&quot;。执行完毕， 调用栈弹出 `promise1ThenCb`。（此时调用栈为空， 微任务队列为: [promise2ThenCb]）。
10. 取出微任务队列中的第一个任务 `promise2ThenCb`，压入调用栈中，并执行，输出 &quot;glob2_then&quot;。执行完毕， 调用栈弹出 `promise2ThenCb`。（此时调用栈为空， 微任务队列为: []）。
- 至此， 第一轮事件循环的 TASK阶段 结束， 进入渲染绘制阶段。
  - 第一轮事件循环，控制台的log应该为： 	
  		&quot;glob1&quot;、&quot;glob1_promise&quot;、&quot;glob2_promise&quot;、&quot;glob1_then&quot;、&quot;glob2_then&quot;
 
--- 绘制完成， 开始第二轮事件循环 ---
1.  `Webapis` 将上个循环中的 `timeout1Cb` 和 `timeout2Cb`依次放入任务队列。（为什么会在第二轮循环就放到任务队列了， 是因为 setTimeout 第二个参数没传, 默认为0，就放到下一个循环中去执行了， 如果第二个参数是一个大于16的数， 那这个任务就可能会到下下个循环中去执行）
2. 在调用栈为空的情况下， 取出第一个任务 `timeout1Cb`， 压入调用栈中， 并执行， 输出 &quot;timeout1&quot;
3. 实例化 promise， 传入 `timeout1PromiseCb` 执行器，执行 `timeout1PromiseCb`。输出 &quot;timeout1_promise&quot;
4. 调用 `resolve();` 往微任务队列中推了一个任务 `timeout1ThenCb`。
5. 到此， `timeout1Cb` 代码执行完毕，调用栈清空。并询问微任务队列是否有值。（此时微任务队列中应该是： [timeout1ThenCb]）。
6. 调用栈清空情况下， 取出微任务队列中的第一个任务 `timeout1ThenCb`，压入调用栈中，并执行，输出 &quot;timeout1_then&quot;。执行完毕， 调用栈弹出 `timeout1ThenCb`。（此时调用栈为空， 微任务队列为: []）。
	- 至此， 第二轮事件循环的第一个任务执行完毕(目前任务队列： [timeout2Cb])

7. 在调用栈为空的情况下， 取出第一个任务 `timeout2Cb`， 压入调用栈中， 并执行， 输出 &quot;timeout2&quot;
8. 实例化 promise， 传入 `timeout2PromiseCb` 执行器，执行 `timeout2PromiseCb`。输出 &quot;timeout2_promise&quot;
9. 调用 `resolve();` 往微任务队列中推了一个任务 `timeout2ThenCb`。
10. 到此， `timeout2Cb` 代码执行完毕，调用栈清空。并询问微任务队列是否有值。（此时微任务队列中应该是： [timeout2ThenCb]）。
11. 调用栈清空情况下， 取出微任务队列中的第一个任务 `timeout2ThenCb`，压入调用栈中，并执行，输出 &quot;timeout2_then&quot;。执行完毕， 调用栈弹出 `timeout2ThenCb`。（此时调用栈为空， 微任务队列为: []）。
	- 至此， 第二轮事件循环的第二个任务执行完毕(目前任务队列： [])

- 至此， 第二轮事件循环的 TASK阶段 结束， 开始进入 渲染部分， 依次走 rAF， Style, Layout, Paint。
  - 第二轮事件循环，控制台的log应该为： 
  		&quot;timeout1&quot;、&quot;timeout1_promise&quot;、&quot;timeout1_then&quot;、&quot;timeout2&quot;、&quot;timeout2_promise&quot;、&quot;timeout2_then&quot;
  
--- 绘制完成， 开始第三轮事件循环 ---
1.  `Webapis`  上没有东西交给 任务队列， 所以此时 任务队列为空， 调用栈为空。于是事件循环进入空转状态。并每隔16ms左右 渲染一次页面。


**/

</code></pre>
<h3 id="2-由script-标签分发出来的任务">② 由script 标签分发出来的任务</h3>
<pre><code class="language-html">&lt;script&gt;
  console.log(&quot;script1 - begin&quot;);

  setTimeout(function cb1() {
    console.log(&quot;script1 - timeout1&quot;);
  });

  Promise.resolve().then(function microCb1(){
    console.log(&quot;script1 - then&quot;)
  });

  console.log(&quot;script1 - end&quot;);
&lt;/script&gt;
&lt;script&gt;
  console.log(&quot;script2 - begin&quot;);

  setTimeout(function cb2() {
    console.log(&quot;script2 - timeout1&quot;);
  });

  Promise.resolve().then(function microCb2(){
    console.log(&quot;script2 - then&quot;)
  });

  console.log(&quot;script2 - end&quot;);
&lt;/script&gt;


&lt;!-- 

解析： 
 ----- 第一轮事件循环 ------ 
1. 初始化js环境，将两个script的任务由  `Webapis`  推入 任务队列。（此时任务队列中有两个任务， 分别为对应的的script）
2. 询问调用栈是否为空， 是， 则取任务队列最前面一个， 压入调用栈执行， 任务队列length减1。
3. 执行第一个 script 中的代码。
4. 执行 `console.log(&quot;script1 - begin&quot;);`， 输出 &quot;script1 - begin&quot;
5. 执行 setTimeout 逻辑， 将cb1交与 `Webapis` , 并让 `Webapis` 在满足条件的情况下将cb1推入任务队列。此时是 0 毫秒后，及下一轮事件循环， 也就是当前事件循环结束后。
6. 执行 Promise.resolve 语句， 并向微任务队列推入一个 `microCb1` 的任务
7. 执行 `console.log(&quot;script1 - end&quot;);`， 输出 &quot;script1 - end&quot;
8. 此时代码执行完毕， 询问 调用栈是否为空 的答案为 true， 则开始执行微任务。
9. 取出微任务队列中的第一个任务 microCb1， 压入调用栈， 开始执行。输出 &quot;script1 - then&quot;， microCb1 执行完毕， 弹出调用栈。（如若还有， 继续重复此操作， 直到微任务队列为空）
10. 微任务此时length为0， 调用栈为空。
  - 此任务执行完毕， 依次输出 &quot;script1 - begin&quot;、&quot;script1 - end&quot; 、&quot;script1 - then&quot;

11. 开始执行下一个任务
12. 询问调用栈是否为空， 是， 则取队列最前面一个， 压入调用栈执行， 任务队列length减1， 则当前任务队列length为0。
13. ... 重复 3 - 10 ... 
 - 此任务执行完毕， 依次输出 &quot;script2 - begin&quot;、&quot;script2 - end&quot; 、&quot;script2 - then&quot;

14. 此时，调用栈为空， 且 任务队列为空。于是便走 渲染 阶段， 依次经过 requestAnimationFrame、 Style Calculation、Layout Calculation、 Pint 阶段（看下面 Event Loop 周期组成）
15. 直到 页面绘制完成， 这第一轮 事件循环 算是结束。于是便开始第二轮事件循环

 ----- 第二轮事件循环 ------ 

16. 我们在 script1 和 script2 中有向 `Webapis` 中分发了一个 cb1和 cb2 ， 在上一轮事件循环中它们一直处于  `Webapis` 中， 未到达任务队列。而此时，  `Webapis` 则会把这两个任务交给 任务队列。
17. 询问调用栈是否为空， 得到回复是 true， 则将任务队列中的 cb1 取出， 压入调用栈。（队列的顺序和分发时候的先后顺序保持一致）
18. 执行 cb1， 输出 &quot;script1 - timeout1&quot;。此时任务执行完毕， 调用栈清空。开始执行微任务， 发现没有微任务。OK， 执行下一个任务。
19. ... 重复 17 - 18 两个步骤, 把调用的 cb1 换成了cb2 ...
 - 上面两个任务执行完毕， 依次输出 &quot;script1 - timeout1&quot; 、&quot;script2 - timeout1&quot;

20. 此时，调用栈为空，且任务全部执行完毕（微任务没执行完毕是不会走下一个任务， 所以此处任务执行完毕的前提条件就是微任务全部执行完毕）
21. ... 重复 14 - 15 两个步骤， 至此， 所有任务执行完毕， 事件循环进行空转（虽说是空转， 其实也是每次都会去判断任务队列是否有值， 当有值并且调用栈为空的时候， 就去进行对应的操作， 取任务， 压栈， 执行，出栈...），并每隔 16.6ms 进行一次视图绘制。...


--&gt;

</code></pre>
<h3 id="3-由事件分发的任务-1">③ 由事件分发的任务 - 1</h3>
<pre><code class="language-html">... 
&lt;button id=&quot;btn&quot;&gt;
  按钮
&lt;/button&gt;


&lt;script&gt;
const btn = document.querySelector('#btn');

btn.addEventListener('click', function click1Cb(){
  Promise.resolve().then(function click1ThenCb() {
    console.log('promise1_then')
  })
  console.log('listener1');
})

btn.addEventListener('click', function click2Cb(){
  Promise.resolve().then(function click2ThenCb() {
    console.log('promise2_then')
  })
  console.log('listener2');
})

&lt;/script&gt;

&lt;!--
解析：
1. 获取btn元素。
2. 给btn绑定click事件， 即 把 `click1Cb` 函数交给  `Webapis` ， 当用户点击了 btn 后，  `Webapis` 会将这个 `click1Cb` 推入任务队列。
3. 给btn绑定click事件， 即 把 `click2Cb` 函数交给  `Webapis` ， 当用户点击了 btn 后，  `Webapis` 会将这个 `click2Cb` 推入任务队列。
4. 第一轮事件循环完毕， 进行空转。


--- 一段时间后 ---
用户点击这个按钮。
1.  `Webapis`  得知按钮点击， 便将 `click1Cb` 、`Click2Cb` 依次放入 任务队列中。
2. 事件循环判断当前调用栈是否为空，以及 任务队列 中是否有值。得到true 的结果后，取出任务队列中的第一个任务 `click1Cb`，压入调用栈中，并执行。
3. 执行 `click1Cb`， 首先 分发了一个微任务 `click1ThenCb` 到微任务队列中。接着走下一行的console.log， 输出 &quot;listener1&quot;
4. `click1Cb` 执行完毕， 调用栈弹出 `click1Cb`， 开始执行微任务， 此时微任务队列为： [click1ThenCb]
5. 取出微任务队列中的第一个微任务 `click1ThenCb`， 压入调用栈中， 并执行。输出 &quot;promise1_then&quot;。`click1ThenCb` 执行完毕， 调用栈弹出 `click1ThenCb`
- 至此，调用栈为空， 微任务队列为空。 第一个任务队列中的第一个任务执行完毕。

1. 取出 任务队列 的第一个任务 `click2Cb`，压入调用栈中，并执行。
2. 执行 `click2Cb`， 首先 分发了一个微任务 `click2ThenCb` 到微任务队列中。接着走下一行的console.log， 输出 &quot;listener2&quot;
3. `click2Cb` 执行完毕， 调用栈弹出 `click2Cb`， 开始执行微任务， 此时微任务队列为： [click2ThenCb]
4. 取出微任务队列中的第一个微任务 `click2ThenCb`， 压入调用栈中， 并执行。输出 &quot;promise2_then&quot;。`click2ThenCb` 执行完毕， 调用栈弹出 `click2ThenCb`
5. 至此，调用栈为空， 微任务队列为空。 第一个任务队列中的第一个任务执行完毕。

综上分析， 此demo的输出就是 &quot;listener1&quot;、 &quot;promise1_then&quot;、&quot;listener2&quot;、&quot;promise2_then&quot;
--&gt;



</code></pre>
<h3 id="4-由事件分发的任务-2">④ 由事件分发的任务 - 2</h3>
<pre><code class="language-html">... 
&lt;button id=&quot;btn&quot;&gt;
  按钮
&lt;/button&gt;


&lt;script&gt;
const btn = document.querySelector('#btn');

btn.addEventListener('click', function click1Cb(){
  Promise.resolve().then(function click1ThenCb() {
    console.log('promise1_then')
  })
  console.log('listener1');
})

btn.addEventListener('click', function click2Cb(){
  Promise.resolve().then(function click2ThenCb() {
    console.log('promise2_then')
  })
  console.log('listener2');
})
  
btn.click();

&lt;/script&gt;

&lt;!--
解析：
1. 获取btn元素。
2. 给btn绑定click事件， 即 把 `click1Cb` 函数交给  `Webapis` ， 当用户点击了 btn 后，  `Webapis` 会将这个 `click1Cb` 推入任务队列。
3. 给btn绑定click事件， 即 把 `click2Cb` 函数交给  `Webapis` ， 当用户点击了 btn 后，  `Webapis` 会将这个 `click2Cb` 推入任务队列。
4. btn 自己触发 click 事件, 调用栈压入 btn.click
5. 内部创建事件对象，缺少的数据由默认值填充。（如 鼠标位置信息等）
6. 依次触发事件（注意， 此次是内部js触发， 相当于自己注册事件，自己触发， 不走 `Webapis` ， 更不走任务队列）
7. 调用栈压入 `click1Cb`，执行 `click1Cb`， 此时调用栈：[ btn.click, click1Cb ]
8. 执行 `click1Cb`， 首先 分发了一个微任务 `click1ThenCb` 到微任务队列中。接着走下一行的console.log， 输出 &quot;listener1&quot;。(此时 微任务队列内容为： [click1ThenCb])
9. `click1Cb` 执行完毕， 调用栈弹出 `click1Cb`，此时调用栈内容为：[btn.click]， 因为调用栈非空， 不能执行微任务， 所以， 进行下一个事件监听函数的触发。 
10. 调用栈压入 `click2Cb`，执行 `click2Cb`。此时调用栈：[ btn.click, click2Cb ]
11. 执行 `click2Cb`， 首先 分发了一个微任务 `click2ThenCb` 到微任务队列中。接着走下一行的console.log， 输出 &quot;listener2&quot;。(此时 微任务队列内容为： [click1ThenCb, click2ThenCb])
12. `click2Cb` 执行完毕， 调用栈弹出 `click2Cb`，调用栈内容为：[btn.click]， 此时没有未触发的事件监听函数了， 所以 btn.click 执行完毕， 调用栈弹出 btn.click， 此时调用栈内容为：[]。 
13. 询问调用栈是否为空，并且是否有未执行的微任务。 得到结果为true。便开始执行微任务。
14. 取出微任务队列中的第一个微任务 `click1ThenCb`， 压入调用栈中， 并执行。输出 &quot;promise1_then&quot;。`click1ThenCb` 执行完毕， 调用栈弹出 `click1ThenCb`。
15. 进行下一个微任务执行， 取出微任务队列中的第一个微任务 `click2ThenCb`， 压入调用栈中， 并执行。输出 &quot;promise2_then&quot;。`click2ThenCb` 执行完毕， 调用栈弹出 `click2ThenCb`。此时， 微任务队列执行完毕。
16. 此时，任务队列为空， 且调用栈为空，便进入 渲染阶段， 渲染结束， 第一轮事件循环完毕。开始后面的事件循环。


综上分析， 此demo的输出就是 &quot;listener1&quot;、 &quot;listener2&quot;、&quot;promise1_then&quot;、&quot;promise2_then&quot;
--&gt;



</code></pre>
<p>两个 事件相关的demo总结：</p>
<p>其实第一个和第二个， 代码层面上看， 不同的就是第一个是需要用户与UI交互进行触发， 第二个是通过js触发。</p>
<p>但是从代码执行的时候看， 就会有这么一些区别：</p>
<ol>
<li>通过 UI 交互进行触发， 就会走 <code>Webapis</code> ， 因为dom 的事件监听都是通过 <code>Webapis</code> 来的。而通过 <code>Webapis</code> ， 在事件触发的时候，  <code>Webapis</code> 则会把事件处理函数推入 任务队列， 等待事件循环的调度与执行。</li>
<li>通过js触发， 这里就相当于一个简单的事件系统，一边去 监听， 一边去触发， 同步的操作，没涉及到异步， 更没涉及到 <code>Webapis</code> ， 任务队列。所以， 在触发事件处理函数的时候，调用栈一直都会有一个 btn.click 函数，等到事件处理函数全部执行完毕， 有了返回值。而 btn.click 才算执行结束。并从 调用栈弹出。清空了调用栈， 才能去执行 事件处理函数中 分发的微任务。</li>
</ol>
<p>到此， 事件循环我个人的理解就是这样。这也是我花了几天时间集中精力去理解得来的一个总结。希望对大家能有一些帮助。</p>
<p>另因为这个只是我个人理解， 所以各位看官看的时候当个参考即可。如果发现我的理解和你们的理解有些出入的， 也欢迎在评论里提出来，一起完善各自对 Event Loop 的理解。</p>
<h2 id="参考资料">参考资料</h2>
<ol>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/HTML_DOM_API/Microtask_guide/In_depth">深入：微任务与Javascript运行时环境</a></li>
<li><a href="https://www.jianshu.com/p/12b9f73c5a4f">前端基础进阶（十四）：深入核心，详解事件循环机制</a></li>
<li><a href="https://www.bilibili.com/video/BV1bE411B7ez">【熟肉 | 内核】深入JavaScript中的EventLoop</a></li>
<li><a href="https://www.bilibili.com/video/BV1oV411k7XY">【自制熟肉】Philip Roberts：到底什么是Event Loop呢？（JSConf EU 2014）</a></li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[渲染与校验]]></title>
        <id>https://croatiaparanoia.github.io/blog/post/xuan-ran-yu-xiao-yan/</id>
        <link href="https://croatiaparanoia.github.io/blog/post/xuan-ran-yu-xiao-yan/">
        </link>
        <updated>2019-04-28T10:01:07.000Z</updated>
        <content type="html"><![CDATA[<p>当时写这个页面， 对我收获最大的应该是一个FormItem组件的Props设计，以及提交时的每一个FormItem的值校验逻辑。</p>
<p>​UI:</p>
<figure data-type="image" tabindex="1"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755396474.png" alt="" loading="lazy"></figure>
<p>输入&amp;选择的Form列表的数据源</p>
<figure data-type="image" tabindex="2"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755402190.png" alt="" loading="lazy"></figure>
<p>使用数据源：</p>
<figure data-type="image" tabindex="3"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755409906.png" alt="" loading="lazy"></figure>
<p>存储用户录入数据的容器：</p>
<figure data-type="image" tabindex="4"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755415123.png" alt="" loading="lazy"></figure>
<p>校验函数：</p>
<figure data-type="image" tabindex="5"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755425140.png" alt="" loading="lazy"></figure>
<p>使用校验函数：</p>
<figure data-type="image" tabindex="6"><img src="https://croatiaparanoia.github.io/blog//post-images/1609755431372.png" alt="" loading="lazy"></figure>
<p>此方式，</p>
<p>一个重点是数据驱动视图， FormItem 的样子， 由props的数据控制。</p>
<p>第二个则是 rules这个校验规则。</p>
<p>如果在以前要判断这些数据是否合法， 需要一个个的写if来判断， 判断得多的话， 基本都是一整页都是if代码</p>
<p>而如果使用rules + 校验函数， 则值需要几行代码， 循环计算然后，抛出有误的提示语句，并大大简洁了代码。</p>
<p>此方式借鉴了 Ant Design 的 <a href="%5Bhttps://ant.design/components/form-cn/#%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99%5D(https://ant.design/components/form-cn/#%E6%A0%A1%E9%AA%8C%E8%A7%84%E5%88%99)">规则校验 | 表单 Form  - Ant Design</a></p>
<p>以及看到别人推荐的一个校验器 <a href="https://github.com/fjc0k/vtils#easyvalidator">fjc0k/vtils: 小巧实用的 JavaScript 工具类库</a></p>
]]></content>
    </entry>
</feed>